## 设计要点
- 在 `StockDailyKLineFetcher` 内部引入 `@cached_property`（functools.cached_property）缓存交易日历 DataFrame（默认 `exchange='SSE'`）。
- 首次访问时：
  - 先尝试从本地 `cache/trade_calendar_SSE.csv` 读取（不存在则创建目录并全量拉取一个基础覆盖区间，如 `20000101` 至当日）。
  - 将合并后的日历缓存到该属性中，并保存到本地文件（去重、排序）。
- 后续访问：
  - `get_trade_calendar(exchange, start_date, end_date)` 直接对 `self.trade_calendar_df` 切片，不触发网络请求。
  - 若请求区间超出缓存范围（`end_date > cached_max` 或 `start_date < cached_min`），调用内部 `ensure_calendar_coverage(start_date, end_date)`：
    - 增量从数据源拉取缺失区间，合并至内存 DataFrame 与本地文件。
    - 为了让 `cached_property` 反映最新值，删除实例属性 `trade_calendar_df`（`del self.trade_calendar_df`），下次访问重新构建缓存（或就地更新 DataFrame）。

## 代码改动
- 新增属性和方法（在 `src/data_fetch/stock_data_fetcher.py`）：
  - `@cached_property def trade_calendar_df(self) -> pd.DataFrame`：加载或初始化缓存。
  - `def ensure_calendar_coverage(self, start_date: str, end_date: str) -> None`：检查覆盖并增量拉取。
- 修改函数：
  - `get_trade_calendar(exchange, start_date, end_date)`：改为使用切片 + 覆盖检查（不再每次落盘固定文件）。
  - `detect_missing_dates(...)`：改为从 `trade_calendar_df` 切片，必要时先 `ensure_calendar_coverage`。
  - `ensure_last_year_complete(ts_code)`：在补齐前预热交易日历 `ensure_calendar_coverage(one_year_ago, today)`。

## 本地持久化
- 路径：`cache/trade_calendar_SSE.csv`（后续如需扩展 SZSE、BSE，可按交换所命名）。
- 写入采用原子保存（临时文件 + 替换），避免并发破坏。
- 每次增量拉取后都会合并并保存（去重、排序）。

## 验证
- 首次运行脚本会创建或更新 `cache/trade_calendar_SSE.csv` 并建立内存缓存。
- 再次调用 `detect_missing_dates` 与 `get_trade_calendar` 同区间只走切片，不触发网络请求。
- 当日期跨天或区间扩大时，仅增量拉取新增区间，再刷新缓存。

## 风险与处理
- 缓存文件损坏：检测到读取失败时，自动回退为重新拉取当前所需区间并重建缓存。
- 多策略或并发：通过原子写入降低文件级别冲突；如需更严格并发控制，可后续加入文件锁。